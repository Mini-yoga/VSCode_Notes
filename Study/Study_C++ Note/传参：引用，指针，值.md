```js
 1 #include<iostream>
 2 using namespace std;
 3 //值传递
 4  void change1(int n){
 5     cout<<"值传递--函数操作地址"<<&n<<endl;         //显示的是拷贝的地址而不是源地址 
 6     n++;
 7 }
 8 
 9 //引用传递
10 void change2(int & n){
11     cout<<"引用传递--函数操作地址"<<&n<<endl; 
12     n++;
13 }
14  //指针传递
15 void change3(int *n){
16      cout<<"指针传递--函数操作地址 "<<n<<endl; 
17     *n=*n+1;
18  } 

int     main(){
20     int n=10;
21     cout<<"实参的地址"<<&n<<endl;
22     change1(n);
23     cout<<"after change1() n="<<n<<endl;
24     change2(n);
25     cout<<"after change2() n="<<n<<endl;
26     change3(&n);
27     cout<<"after change3() n="<<n<<endl;
28     return true;
29 }
```

一 、值传递：

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，

不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

二 、指针传递：

形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作



 

三  、引用参数：
引用传递：
形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

1、传递可变参数
传统的c中，函数在调用时参数是通过值来传递的，这就是说函数的参数不具备返回值的能力。
所以在传统的c中，如果需要函数的参数具有返回值的能力，往往是通过指针来实现的。比如，实现
两整数变量值交换的c程序如下：
void swapint(int *a,int *b)
{
int temp;
temp=*a;
a=*b;
*b=temp;
}

使用引用机制后，以上程序的c++版本为：
void swapint(int &a,int &b)
{
int temp;
temp=a;
a=b;
b=temp;
}

2、给函数传递大型对象
当大型对象被传递给函数时，使用引用参数可使参数传递效率得到提高，因为引用并不产生对象的
副本，也就是参数传递时，对象无须复制。

3、引用返回值

如果一个函数返回了引用，那么该函数的调用也可以被赋值。这里有一函数，它拥有两个引用参数并返回一个双精度数的引用：
double &max(double &d1,double &d2)
{
return d1>d2?d1:d2;
}
由于max()函数返回一个对双精度数的引用，那么我们就可以用max() 来对其中较大的双精度数加1：
max(x,y)+=1.0;





总结一下指针和引用的相同点和不同点：

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

★不同点：

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

●引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有     的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

●引用不能为空，指针可以为空；

●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

