Meta-Object Compiler，也就是“元对象编译器”。Qt 程序在交由标准编译器编译之前，先要使用 moc 分析 C++ 源文件。如果它发现在一个头文件中包含了宏 Q_OBJECT，则会生成另外一个 C++ 源文件。这个源文件中包含了 Q_OBJECT 宏的实现代码。这个新的文件名字将会是原文件名前面加上 moc_ 构成。这个新的文件同样将进入编译系统，最终被链接到二进制代码中去。因此我们可以知道，这个新的文件不是“替换”掉旧的文件，而是与原文件一起参与编译。另外，我们还可以看出一点，moc 的执行是在预处理器之前。因为预处理器执行之后，Q_OBJECT 宏就不存在了。

既然每个源文件都需要 moc 去处理，那么我们在什么时候调用了它呢？实际上，如果你使用 qmake 的话，这一步调用会在生成的 makefile 中展现出来。从本质上来说，qmake 不过是一个 makefile 生成器，因此，最终执行还是通过 make 完成的。

对 Q_OBJECT 宏的展开，使我们的 Test 类拥有了这些多出来的属性和函数。注意，QT_TR_FUNCTIONS 这个宏也是在这里定义的。也就是说，如果你要使用 tr() 国际化，就必须使用 Q_OBJECT 宏，否则是没有 tr() 函数的。这期间最重要的就是 virtual const QMetaObject *metaObject() const; 函数。这个函数返回 QMetaObject 元对象类的实例，通过它，你就获得了 Qt 类的反射的能力：获取本对象的类型之类，而这一切，都不需要 C++ 编译器的 RTTI 支持。Qt 也提供了一个类似 C++ 的 dynamic_cast() 的函数 qobject_case()，而这一函数的实现也不需要 RTTI。另外，一个没有定义 Q_OBJECT 宏的类与它最接近的父类是同一类型的。也就是说，如果 A 继承了 QObject 并且定义了 Q_OBJECT，B 继承了 A 但没有定义 Q_OBJECT，C 继承了 B，则 C 的 QMetaObject::className() 函数将返回 A，而不是本身的名字。因此，为了避免这一问题，所有继承了 QObject 的类都应该定义 Q_OBJECT 宏，不管你是不是使用信号槽。